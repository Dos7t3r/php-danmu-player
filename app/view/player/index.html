<!DOCTYPE html>
<html lang="zh-CN">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>{$videoTitle} | OBP v2.0</title>
   <style>
   /* --- 基本重置与布局 --- */
   * {
       margin: 0;
       padding: 0;
       box-sizing: border-box;
   }

   html, body {
       width: 100%;
       height: 100%;
       overflow: hidden;
       background-color: #000;
       position: relative;
   }

   /* --- Artplayer 容器 --- */
   .artplayer-app {
       width: 100%;
       height: calc(100% - 1px);
       position: relative;
   }

   /* 现代化通知系统样式 */
   .notifications-container {
       position: fixed;
       top: 20px;
       right: 20px;
       z-index: 1000;
       display: flex;
       flex-direction: column;
       gap: 10px;
       max-width: 90%;
       width: 300px;
   }

   @media (max-width: 480px) {
       .notifications-container {
           top: 10px;
           right: 10px;
           width: calc(100% - 20px);
       }
   }

   .notification {
       display: flex;
       align-items: center;
       padding: 12px 15px;
       border-radius: 8px;
       color: white;
       font-family: Arial, sans-serif;
       font-size: 14px;
       box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
       transform: translateX(100%);
       opacity: 0;
       transition: transform 0.3s ease, opacity 0.3s ease;
       position: relative;
       overflow: hidden;
       border: 1px solid rgba(255, 255, 255, 0.1);
       backdrop-filter: blur(8px);
   }

   /* 不同类型的通知背景色 */
   .notification.success { background: linear-gradient(to right, rgba(46, 204, 113, 0.9), rgba(39, 174, 96, 0.9)); }
   .notification.error   { background: linear-gradient(to right, rgba(231, 76, 60, 0.9), rgba(192, 57, 43, 0.9)); }
   .notification.loading { background: linear-gradient(to right, rgba(52, 152, 219, 0.9), rgba(41, 128, 185, 0.9)); }
   .notification.info    { background: linear-gradient(to right, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9)); }

   .notification.show {
       transform: translateX(0);
       opacity: 1;
   }

   .notification-icon {
       margin-right: 10px;
       flex-shrink: 0;
       width: 20px;
       height: 20px;
       display: flex;
       align-items: center;
       justify-content: center;
   }

   .notification-content {
       flex-grow: 1;
       word-break: break-word;
   }

   .notification-close {
       margin-left: 10px;
       cursor: pointer;
       opacity: 0.7;
       transition: opacity 0.2s;
       flex-shrink: 0;
       width: 16px;
       height: 16px;
   }
   .notification-close:hover { opacity: 1; }

   .notification-progress {
       position: absolute;
       bottom: 0;
       left: 0;
       height: 3px;
       background-color: rgba(255, 255, 255, 0.3);
       width: 100%;
       transform-origin: left;
   }

   /* 加载中图标旋转动画 */
   @keyframes spin {
       0% { transform: rotate(0deg); }
       100% { transform: rotate(360deg); }
   }
   .spin { animation: spin 1.5s linear infinite; }

   /* --- 弹幕列表样式 --- */
   .art-danmuku-list {
       position: absolute;
       top: 30px;
       right: 20px;
       width: 300px;
       height: calc(100% - 90px);
       background-color: rgba(0, 0, 0, 0.85);
       backdrop-filter: blur(10px);
       z-index: 100;
       display: none;
       flex-direction: column;
       color: #fff;
       border-radius: 8px;
       box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
       border: 1px solid rgba(255, 255, 255, 0.1);
       opacity: 0;
       transform: translateX(20px);
       transition: opacity 0.3s ease, transform 0.3s ease;
       overflow: hidden;
   }

   .art-danmuku-list.show {
       display: flex;
       opacity: 1;
       transform: translateX(0);
   }

   .art-danmuku-list-header {
       padding: 6px 10px;
       border-bottom: 1px solid rgba(255, 255, 255, 0.1);
       display: flex;
       justify-content: space-between;
       align-items: center;
       border-radius: 8px 8px 0 0;
       flex-shrink: 0;
   }

   .art-danmuku-list-title {
       display: flex;
       align-items: center;
       gap: 5px;
       font-weight: bold;
       font-size: 14px;
   }
   .art-danmuku-list-title span { flex-grow: 1; }

   .art-danmuku-list-close {
       margin-left: auto;
       padding: 2px;
       cursor: pointer;
       opacity: 0.7;
       transition: opacity 0.2s;
       display: flex;
       align-items: center;
       justify-content: center;
       flex-shrink: 0;
   }
   .art-danmuku-list-close:hover { opacity: 1; }

   .art-danmuku-list-online {
       display: flex;
       align-items: center;
       gap: 5px;
       font-size: 12px;
       color: rgba(255, 255, 255, 0.7);
       flex-shrink: 0;
   }

   .art-danmuku-list-content {
       flex: 1;
       overflow-y: auto;
       overflow-x: hidden;
       padding: 0;
       scrollbar-width: thin;
       scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.3);
   }
   
   .art-danmuku-list-content::-webkit-scrollbar {
       width: 6px;
   }
   .art-danmuku-list-content::-webkit-scrollbar-track {
       background: rgba(0, 0, 0, 0.3);
       border-radius: 3px;
   }
   .art-danmuku-list-content::-webkit-scrollbar-thumb {
       background-color: rgba(255, 255, 255, 0.3);
       border-radius: 3px;
   }
   .art-danmuku-list-content::-webkit-scrollbar-thumb:hover {
       background-color: rgba(255, 255, 255, 0.5);
   }

   .art-danmuku-list-content table {
       width: 100%;
       table-layout: fixed;
       border-collapse: collapse;
       font-size: 12px;
   }

   .art-danmuku-list-content th,
   .art-danmuku-list-content td {
       padding: 4px 8px;
       text-align: left;
       border-bottom: 1px solid rgba(255, 255, 255, 0.05);
       line-height: 1.4;
       white-space: nowrap;
       overflow: hidden;
       text-overflow: ellipsis;
       vertical-align: middle;
   }
   .art-danmuku-list-content tr:last-child td {
       border-bottom: none;
   }

   /* 列宽设置 */
   .art-danmuku-list-content th:nth-child(1),
   .art-danmuku-list-content td:nth-child(1) { width: 60px; text-align: center;}

   .art-danmuku-list-content th:nth-child(2),
   .art-danmuku-list-content td:nth-child(2) { width: auto; }

   .art-danmuku-list-content th:nth-child(3),
   .art-danmuku-list-content td:nth-child(3) { width: 85px; text-align: right; color: rgba(255, 255, 255, 0.6); }

   .art-danmuku-list-content th {
       font-weight: normal;
       color: rgba(255, 255, 255, 0.5);
       font-size: 11px;
       padding-top: 6px;
       padding-bottom: 6px;
       position: sticky;
       top: 0;
       background-color: rgba(0, 0, 0, 0.85);
       z-index: 1;
   }

   /* 响应式设计：小屏幕调整弹幕列表 */
   @media (max-width: 768px) {
       .art-danmuku-list {
           width: calc(100% - 60px);
           right: 10px;
           top: 10px;
           max-height: calc(100% - 60px);
       }
       .art-danmuku-list-content table { font-size: 11px; }
       .art-danmuku-list-content th:nth-child(1),
       .art-danmuku-list-content td:nth-child(1) { width: 50px; }
       .art-danmuku-list-content th:nth-child(3),
       .art-danmuku-list-content td:nth-child(3) { width: 75px; }
   }

   .art-danmuku-list-empty {
       display: flex;
       flex-direction: column;
       align-items: center;
       justify-content: center;
       padding: 30px 20px;
       color: rgba(255, 255, 255, 0.5);
       font-size: 13px;
       text-align: center;
       flex-grow: 1;
   }
   .art-danmuku-list-empty svg {
       width: 32px;
       height: 32px;
       margin-bottom: 15px;
       opacity: 0.4;
   }
   .art-danmuku-list-empty small {
       margin-top: 5px;
       font-size: 11px;
       color: rgba(255, 255, 255, 0.4);
   }

   /* 弹幕面板遮罩层 */
   .art-danmuku-overlay {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       z-index: 99;
       display: none;
   }

/* 修改移动端弹幕控制面板样式 */
.mobile-danmuku-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    z-index: 101; /* 确保高于遮罩层 */
    padding: 10px;
    display: none;
    flex-direction: column;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    transform: translateY(100%);
    transition: transform 0.3s ease;
}

.mobile-danmuku-controls.show {
    transform: translateY(0);
}

/* 移动端弹幕控制面板遮罩层 */
.mobile-danmuku-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 99; /* 确保低于控制面板 */
    display: none;
}

/* 移除固定定位的弹幕按钮样式 */
.mobile-danmuku-toggle,
.mobile-danmuku-visibility-toggle {
    display: none; /* 默认隐藏，将在JS中添加到控制栏 */
}

/* 为控制栏中的弹幕按钮添加样式 */
.art-control-danmuku-send,
.art-control-danmuku-visibility {
    opacity: 0.8;
    transition: opacity 0.2s;
    cursor: pointer;
}

.art-control-danmuku-send:hover,
.art-control-danmuku-visibility:hover {
    opacity: 1;
}

/* 新增：悬浮弹幕控制面板 */
.floating-danmuku-panel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    z-index: 200;
    display: none;
    flex-direction: column;
    color: white;
    padding: 15px;
}

.floating-danmuku-panel.show {
    display: flex;
}

.floating-danmuku-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 10px;
}

.floating-danmuku-title {
    font-size: 16px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
}

.floating-danmuku-close {
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s;
    padding: 5px;
}

.floating-danmuku-close:hover {
    opacity: 1;
}

.floating-danmuku-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.floating-danmuku-input-row {
    display: flex;
    gap: 10px;
}

.floating-danmuku-input {
    flex: 1;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: white;
    padding: 10px 12px;
    font-size: 14px;
}

.floating-danmuku-input::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

.floating-danmuku-send {
    background-color: #00a1d6;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 10px 15px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
}

.floating-danmuku-send:hover {
    background-color: #00b5e5;
}

.floating-danmuku-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.floating-danmuku-option-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.floating-danmuku-option-label {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.8);
}

.floating-danmuku-color-picker {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.color-option {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: transform 0.2s;
}

.color-option:hover {
    transform: scale(1.1);
}

.color-option.active {
    border-color: white;
}

.floating-danmuku-mode {
    display: flex;
    gap: 10px;
}

.mode-option {
    padding: 5px 10px;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.mode-option:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

.mode-option.active {
    background-color: rgba(255, 255, 255, 0.3);
    color: white;
}

.floating-danmuku-switch {
    display: flex;
    align-items: center;
    gap: 10px;
}

.switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.2);
    transition: .4s;
    border-radius: 20px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: #00a1d6;
}

input:checked + .slider:before {
    transform: translateX(20px);
}

/* 移除移动端限制，改为通过JS控制显示/隐藏 */
@media (max-width: 767px) {
    .art-video-player.mobile-danmuku-open .art-bottom {
        bottom: 120px !important;
    }
}
</style>
   <!-- 添加HLS.js库 -->
   <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
   <script src="https://cdn.jsdelivr.net/npm/artplayer/dist/artplayer.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/artplayer-plugin-danmuku/dist/artplayer-plugin-danmuku.js"></script>
</head>
<body>
<div class="artplayer-app"></div>
<div class="notifications-container" id="notifications-container"></div>

<!-- 移动端弹幕控制面板遮罩层 -->
<div class="mobile-danmuku-overlay" id="mobile-danmuku-overlay"></div>

<!-- 移动端弹幕控制面板 -->
<div class="mobile-danmuku-controls" id="mobile-danmuku-controls">
    <div class="mobile-danmuku-form">
        <div class="mobile-danmuku-input-row">
            <input type="text" class="mobile-danmuku-input" id="mobile-danmuku-text" placeholder="发送弹幕...">
            <button class="mobile-danmuku-send" id="mobile-danmuku-send">发送</button>
        </div>
        <div class="mobile-danmuku-options">
            <div class="mobile-danmuku-color-picker" id="mobile-danmuku-colors">
                <div class="color-option active" data-color="#FFFFFF" style="background-color: #FFFFFF;"></div>
                <div class="color-option" data-color="#FE0302" style="background-color: #FE0302;"></div>
                <div class="color-option" data-color="#00CD00" style="background-color: #00CD00;"></div>
                <div class="color-option" data-color="#0000FE" style="background-color: #0000FE;"></div>
                <div class="color-option" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                <div class="color-option" data-color="#FE7204" style="background-color: #FE7204;"></div>
            </div>
            <div class="mobile-danmuku-mode" id="mobile-danmuku-modes">
                <div class="mode-option active" data-mode="0">滚动</div>
                <div class="mode-option" data-mode="1">顶部</div>
                <div class="mode-option" data-mode="2">底部</div>
            </div>
            <div class="mobile-danmuku-switch">
                <span>弹幕</span>
                <label class="switch">
                    <input type="checkbox" id="mobile-danmuku-switch" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
</div>

<!-- 新增：悬浮弹幕控制面板 -->
<div class="floating-danmuku-panel" id="floating-danmuku-panel">
    <div class="floating-danmuku-header">
        <div class="floating-danmuku-title">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            发送弹幕
        </div>
        <div class="floating-danmuku-close" id="floating-danmuku-close">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </div>
    </div>
    <div class="floating-danmuku-content">
        <div class="floating-danmuku-input-row">
            <input type="text" class="floating-danmuku-input" id="floating-danmuku-text" placeholder="发送弹幕...">
            <button class="floating-danmuku-send" id="floating-danmuku-send">发送</button>
        </div>
        <div class="floating-danmuku-options">
            <div class="floating-danmuku-option-row">
                <div class="floating-danmuku-option-label">颜色</div>
                <div class="floating-danmuku-color-picker" id="floating-danmuku-colors">
                    <div class="color-option active" data-color="#FFFFFF" style="background-color: #FFFFFF;"></div>
                    <div class="color-option" data-color="#FE0302" style="background-color: #FE0302;"></div>
                    <div class="color-option" data-color="#00CD00" style="background-color: #00CD00;"></div>
                    <div class="color-option" data-color="#0000FE" style="background-color: #0000FE;"></div>
                    <div class="color-option" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                    <div class="color-option" data-color="#FE7204" style="background-color: #FE7204;"></div>
                    <div class="color-option" data-color="#FFAA02" style="background-color: #FFAA02;"></div>
                    <div class="color-option" data-color="#4266BE" style="background-color: #4266BE;"></div>
                </div>
            </div>
            <div class="floating-danmuku-option-row">
                <div class="floating-danmuku-option-label">模式</div>
                <div class="floating-danmuku-mode" id="floating-danmuku-modes">
                    <div class="mode-option active" data-mode="0">滚动</div>
                    <div class="mode-option" data-mode="1">顶部</div>
                    <div class="mode-option" data-mode="2">底部</div>
                </div>
            </div>
            <div class="floating-danmuku-option-row">
                <div class="floating-danmuku-option-label">弹幕开关</div>
                <div class="floating-danmuku-switch">
                    <label class="switch">
                        <input type="checkbox" id="floating-danmuku-switch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
   // --- 控制台水印 & ASCII LOGO（OldBili Player Style）---
   console.log(`%c
   /$$$$$$  /$$       /$$ /$$$$$$$  /$$ /$$ /$$
  /$$__  $$| $$      | $$| $$__  $$|__/| $$|__/
 | $$  \\ $$| $$  /$$$$$$$| $$  \\ $$ /$$| $$ /$$
 | $$  | $$| $$ /$$__  $$| $$$$$$$ | $$| $$| $$
 | $$  | $$| $$| $$  | $$| $$__  $$| $$| $$| $$
 | $$  | $$| $$| $$  | $$| $$  \\ $$| $$| $$| $$
 |  $$$$$$/| $$|  $$$$$$$| $$$$$$$/| $$| $$| $$
  /$$$$$$$ |/$$ \\_______/|_______/ |__/|__/|__/
 | $$__  $$| $$
 | $$  \\ $$| $$  /$$$$$$  /$$   /$$  /$$$$$$   /$$$$$$
 | $$$$$$$/| $$ |____  $$| $$  | $$ /$$__  $$ /$$__  $$
 | $$____/ | $$  /$$$$$$$| $$  | $$| $$$$$$$$| $$  \\__/
 | $$      | $$ /$$__  $$| $$  | $$| $$_____/| $$
 | $$      | $$|  $$$$$$$|  $$$$$$$|  $$$$$$$| $$
 |__/      |__/ \\_______/ \\____  $$ \\_______/|__/
                          /$$  | $$
                         |  $$$$$$/
                          \\______/

          OldBili Player v2.1.2 (ThinkPHP Edition)
 `, 'color: #42b983; font-weight: bold; font-size: 13px; font-family: monospace;');
   console.log('%cPowered by: ThinkPHP 6 + AdminLTE 3  https://github.com/oldbili/oldbiliplayer', 'color: #888; font-size: 12px;');
   console.log('%c⚠️ 请勿在控制台粘贴任何不明代码！以防泄露账号信息。', 'color: red; font-size: 14px; font-weight: bold;');

   // --- 工具函数：获取 URL 参数 ---
   function getUrlParameter(name) {
       const search = decodeURIComponent(location.search);
       const regex = new RegExp('[\\?&]' + name.replace(/[\[\]]/g, '\\$&') + '=([^&#]*)');
       const results = regex.exec(search);
       return results === null ? '' : (results[1] || '');
   }

   // --- 现代化通知系统对象 ---
   const notification = {
       container: document.getElementById('notifications-container'),
       activeNotifications: {},
       icons: {
           success: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`,
           error: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`,
           loading: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>`,
           info: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`,
           close: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`
       },
       show(message, type = 'success', duration = 3000) {
           console.log(`[通知] 类型: ${type}, 信息: ${message}`);
           const id = Date.now() + Math.random();
           const notificationEl = document.createElement('div');
           notificationEl.className = `notification ${type}`;
           notificationEl.innerHTML = `
               <div class="notification-icon">${this.icons[type] || this.icons.info}</div>
               <div class="notification-content">${message}</div>
               <div class="notification-close">${this.icons.close}</div>
               ${duration > 0 && type !== 'loading' ? '<div class="notification-progress"></div>' : ''}
           `;
           this.container.appendChild(notificationEl);
           this.activeNotifications[id] = { element: notificationEl, timeout: null, progressInterval: null };
           setTimeout(() => { notificationEl.classList.add('show'); }, 10);

           if (duration > 0 && type !== 'loading') {
               const progressEl = notificationEl.querySelector('.notification-progress');
               if (progressEl) {
                   let progress = 100;
                   const interval = 100; // Update every 100ms
                   const step = 100 / (duration / interval);

                   this.activeNotifications[id].progressInterval = setInterval(() => {
                       progress -= step;
                       if (progress <= 0) {
                           clearInterval(this.activeNotifications[id].progressInterval);
                           progress = 0;
                       }
                       progressEl.style.transform = `scaleX(${progress / 100})`;
                   }, interval);
               }
               this.activeNotifications[id].timeout = setTimeout(() => { this.hide(id); }, duration);
           }

           const closeBtn = notificationEl.querySelector('.notification-close');
           closeBtn.addEventListener('click', () => { this.hide(id); });
           return id;
       },
       hide(id) {
           const notificationData = this.activeNotifications[id];
           if (!notificationData) return;
           if (notificationData.timeout) { clearTimeout(notificationData.timeout); }
           if (notificationData.progressInterval) { clearInterval(notificationData.progressInterval); }

           notificationData.element.classList.remove('show');
           setTimeout(() => {
               if (notificationData.element.parentNode) {
                   notificationData.element.parentNode.removeChild(notificationData.element);
               }
               delete this.activeNotifications[id];
           }, 300); // Wait for transition
       },
       hideAll() {
           Object.keys(this.activeNotifications).forEach(id => { this.hide(id); });
       }
   };

   // --- 初始加载和参数处理 ---
   const loadingId = notification.show('正在加载资源...', 'loading', 0); // Show indefinitely until hidden
   const videoUrl = '{$videoUrl|raw}'; // 视频 URL
   const hasDmkParam = {$hasDanmuTable ? 'true' : 'false'}; // 是否有弹幕
   const videoId = '{$videoId|raw}'; // 视频ID，用于在线人数统计
   const subtitleUrl = '{$subtitleUrl|raw}'; // 字幕 URL
   const obvId = {$obvId ?: 0}; // 视频映射ID

   // 预加载的弹幕数据
   const preloadedDanmakuData = {$danmakuDataJson|raw};

   // --- 在线用户统计系统 ---
   const onlineUserSystem = {
       userId: null,
       onlineCount: 0,
       heartbeatInterval: null,
       heartbeatDelay: 30000, // 30秒发送一次心跳
       videoId: videoId,

       init() {
           this.userId = this.getCookie('online_user_id');
           this.sendHeartbeat(); // Send initial heartbeat
           this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), this.heartbeatDelay);
           window.addEventListener('beforeunload', () => clearInterval(this.heartbeatInterval));
           // Initial fetch of count without waiting for heartbeat
           this.getOnlineCount();
       },
       sendHeartbeat() {
           const formData = new FormData();
           if (this.userId) formData.append('user_id', this.userId);
           if (this.videoId) formData.append('video_id', this.videoId);

           fetch('/heartbeat', { 
               method: 'POST', 
               body: formData,
               headers: {
                   'Accept': 'application/json'
               }
           })
           .then(response => response.json())
           .then(data => {
               if (data.success) {
                   if (!this.userId && data.user_id) this.userId = data.user_id; // Update user ID if new
                   this.updateOnlineCount(data.count);
               } else {
                   console.warn('心跳响应失败:', data.message);
               }
           })
           .catch(error => console.error('在线用户心跳发送失败:', error));
       },
       getOnlineCount() {
           let url = '/onlineCount';
           if (this.videoId) url += '?video_id=' + encodeURIComponent(this.videoId);

           fetch(url, {
               headers: {
                   'Accept': 'application/json'
               }
           })
           .then(response => response.json())
           .then(data => {
               if (data.success) {
                   this.updateOnlineCount(data.count);
               } else {
                   console.warn('获取在线人数失败:', data.message);
               }
           })
           .catch(error => console.error('获取在线人数失败:', error));
       },
       updateOnlineCount(count) {
           this.onlineCount = count;
           const onlineElements = document.querySelectorAll('.online-user-count');
           onlineElements.forEach(element => element.textContent = count);

           // Update Danmuku List Online Count Display (if exists)
           const danmukuListOnline = document.querySelector('.art-danmuku-list-online');
           if (danmukuListOnline) {
               const danmukuCountEl = document.querySelector('.danmuku-count');
               const currentDanmukuCount = danmukuCountEl ? danmukuCountEl.textContent : '0';
               danmukuListOnline.innerHTML = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                       <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                       <circle cx="9" cy="7" r="4"></circle>
                       <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                       <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                   </svg>
                   <span><span class="online-user-count">${count}</span> 人在线，<span class="danmuku-count">${currentDanmukuCount}</span>条弹幕</span>
               `;
           }
       },
       getCookie(name) {
           const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
           return match ? match[2] : null;
       }
   };

   // --- 响应式弹幕字体大小逻辑 ---
   let artInstance = null; // 用于存储 Artplayer 实例
   const mobileMediaQuery = window.matchMedia("(max-width: 767px)");

   function getDanmakuFontSize(isMobile) {
       return isMobile ? 15 : 25;
   }

   function updateDanmakuFontSize() {
       if (artInstance && artInstance.plugins && artInstance.plugins.artplayerPluginDanmuku) {
           const isMobile = mobileMediaQuery.matches;
           const newSize = getDanmakuFontSize(isMobile);
           const danmukuPlugin = artInstance.plugins.artplayerPluginDanmuku;
           // Check if config method exists and option can be accessed
           if (typeof danmukuPlugin.config === 'function' && danmukuPlugin.option) {
               const currentSize = danmukuPlugin.option.fontSize;
               if (newSize !== currentSize) {
                   console.log(`窗口大小变化，更新弹幕字号为: ${newSize}`);
                   try {
                       danmukuPlugin.config('fontSize', newSize);
                       // Ensure resize is called if available
                       if (typeof danmukuPlugin.resize === 'function') {
                           danmukuPlugin.resize();
                       }
                   } catch(e) {
                       console.error("更新弹幕字体大小失败:", e);
                   }
               }
           } else {
               console.warn("无法访问弹幕插件配置或 config 方法。");
           }
       }
   }

   function debounce(func, wait) {
       let timeout;
       return function executedFunction(...args) {
           const later = () => {
               clearTimeout(timeout);
               func(...args);
           };
           clearTimeout(timeout);
           timeout = setTimeout(later, wait);
       };
   }

   const debouncedUpdateFontSize = debounce(updateDanmakuFontSize, 250);

   if (mobileMediaQuery.addEventListener) {
       mobileMediaQuery.addEventListener('change', debouncedUpdateFontSize);
   } else if (mobileMediaQuery.addListener) { // Fallback for older browsers
       mobileMediaQuery.addListener(debouncedUpdateFontSize);
   }

   // --- 全局变量和弹幕加载 ---
   let globalDanmukuData = [];
   let isDanmukuPanelOpen = false;
   let isDanmukuVisible = true; // 弹幕显示状态
   let isFloatingPanelOpen = false; // 悬浮弹幕面板状态

   // --- 弹幕列表功能 ---
   function addDanmukuListFeature(art) {
       if (!art) {
           console.error("ArtPlayer未加载，无法添加弹幕列表功能");
           return null;
       }

       const controlsRight = art.template.$controlsRight;
       if (!controlsRight) {
           console.error("无法找到 ArtPlayer 控制栏右侧容器");
           return null;
       }

       const danmukuListButton = document.createElement("div");
       danmukuListButton.className = "art-control art-control-danmuku-list";
       danmukuListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="art-icon"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>`;
       danmukuListButton.title = "弹幕列表";

       const danmukuOverlay = document.createElement("div");
       danmukuOverlay.className = "art-danmuku-overlay";

       const danmukuListPanel = document.createElement("div");
       danmukuListPanel.className = "art-danmuku-list";
       danmukuListPanel.style.display = "none";

       const danmukuListHeader = document.createElement("div");
       danmukuListHeader.className = "art-danmuku-list-header";

       const danmukuListTitle = document.createElement("div");
       danmukuListTitle.className = "art-danmuku-list-title";
       danmukuListTitle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg><span>弹幕列表</span>`;

       const danmukuListClose = document.createElement("div");
       danmukuListClose.className = "art-danmuku-list-close";
       danmukuListClose.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
       danmukuListClose.addEventListener("click", (e) => {
           e.stopPropagation();
           toggleDanmukuPanel(false);
       });
       danmukuListTitle.appendChild(danmukuListClose); // Append close button inside title container

       const danmukuListOnline = document.createElement("div");
       danmukuListOnline.className = "art-danmuku-list-online";
       // Initial state will be updated by onlineUserSystem and updateDanmukuList
       danmukuListOnline.innerHTML = `<span><span class="online-user-count">?</span> 人在线，<span class="danmuku-count">?</span>条弹幕</span>`;

       danmukuListHeader.appendChild(danmukuListTitle);
       danmukuListHeader.appendChild(danmukuListOnline);

       const danmukuListContent = document.createElement("div");
       danmukuListContent.className = "art-danmuku-list-content";

       const danmukuTable = document.createElement("table");
       const danmukuTableHead = document.createElement("thead");
       danmukuTableHead.innerHTML = "<tr><th>时间</th><th>弹幕内容</th><th>发送时间</th></tr>";
       const danmukuTableBody = document.createElement("tbody");
       danmukuTable.appendChild(danmukuTableHead);
       danmukuTable.appendChild(danmukuTableBody);
       danmukuListContent.appendChild(danmukuTable);

       // 在 danmukuListPanel 的定义后添加内容部分
       danmukuListPanel.appendChild(danmukuListHeader);
       danmukuListPanel.appendChild(danmukuListContent);

       // Insert button before the fullscreen button if possible
       const fullscreenButton = controlsRight.querySelector(".art-control-fullscreen");
       if (fullscreenButton) {
           controlsRight.insertBefore(danmukuListButton, fullscreenButton);
       } else {
           controlsRight.appendChild(danmukuListButton); // Fallback append
       }

       art.template.$player.appendChild(danmukuOverlay);
       art.template.$player.appendChild(danmukuListPanel);

       function formatTime(seconds) {
           const h = Math.floor(seconds / 3600);
           const m = Math.floor((seconds % 3600) / 60);
           const s = Math.floor(seconds % 60);
           return [
               h > 0 ? h.toString().padStart(2, "0") : "",
               m.toString().padStart(2, "0"),
               s.toString().padStart(2, "0")
           ].filter(Boolean).join(":");
       }

       function formatDate(timestamp) {
           if (!timestamp || typeof timestamp !== 'number') return '未知';
           try {
               const date = new Date(timestamp);
               if (isNaN(date.getTime())) return '无效日期'; // Check if date is valid
               const month = (date.getMonth() + 1).toString().padStart(2, "0");
               const day = date.getDate().toString().padStart(2, "0");
               const hours = date.getHours().toString().padStart(2, "0");
               const minutes = date.getMinutes().toString().padStart(2, "0");
               return `${month}-${day} ${hours}:${minutes}`;
           } catch (e) {
               console.error("格式化日期错误:", e, "时间戳:", timestamp);
               return '错误日期';
           }
       }

       function toggleDanmukuPanel(show) {
           if (show === undefined) {
               show = danmukuListPanel.style.display === "none";
           }
           isDanmukuPanelOpen = show;
           if (show) {
               danmukuOverlay.style.display = "block";
               danmukuListPanel.style.display = "flex";
               setTimeout(() => danmukuListPanel.classList.add("show"), 10); // Animate in
               updateDanmukuList(); // Update content when opened
               onlineUserSystem.getOnlineCount(); // Refresh online count when opened
           } else {
               danmukuOverlay.style.display = "none";
               danmukuListPanel.classList.remove("show");
               setTimeout(() => danmukuListPanel.style.display = "none", 300); // Hide after animation
           }
       }

       function updateDanmukuList() {
           // Remove existing empty message if present
           const existingEmpty = danmukuListContent.querySelector(".art-danmuku-list-empty");
           if (existingEmpty) existingEmpty.remove();
           danmukuTable.style.display = "table"; // Ensure table is visible by default

           // Use the globally loaded and sorted data
           const danmukuQueue = globalDanmukuData || [];
           danmukuTableBody.innerHTML = ""; // Clear previous entries

           const onlineUsers = onlineUserSystem.onlineCount || 0;
           const danmukuCount = danmukuQueue.length;

           // Update header info
           danmukuListOnline.innerHTML = `
               <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                   <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                   <circle cx="9" cy="7" r="4"></circle>
                   <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                   <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
               </svg>
               <span><span class="online-user-count">${onlineUsers}</span> 人在线，<span class="danmuku-count">${danmukuCount}</span>条弹幕</span>
           `;

           if (!hasDmkParam) {
               danmukuTable.style.display = "none"; // Hide table
               const emptyContainer = document.createElement("div");
               emptyContainer.className = "art-danmuku-list-empty";
               emptyContainer.innerHTML = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                   <div>未装载弹幕池</div>
                   <small>(视频ID: ${obvId} 没有弹幕数据)</small>
               `;
               danmukuListContent.appendChild(emptyContainer);
           } else if (danmukuCount === 0) {
               danmukuTable.style.display = "none"; // Hide table
               const emptyContainer = document.createElement("div");
               emptyContainer.className = "art-danmuku-list-empty";
               emptyContainer.innerHTML = `
                   <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                   <div>当前弹幕池暂无弹幕</div>
               `;
               danmukuListContent.appendChild(emptyContainer);
           } else {
               // Populate table if data exists
               danmukuQueue.forEach((danmu) => {
                   const row = document.createElement("tr");
                   const timeCell = document.createElement("td");
                   const contentCell = document.createElement("td");
                   const dateCell = document.createElement("td");

                   timeCell.textContent = formatTime(danmu.time);
                   timeCell.title = `视频时间: ${formatTime(danmu.time)}`;

                   contentCell.textContent = danmu.text;
                   contentCell.title = danmu.text; // Tooltip for full content
                   if (danmu.color) contentCell.style.color = danmu.color; // Apply color if available

                   // Use timestamp for date, fallback to '未知' if missing/invalid
                   dateCell.textContent = formatDate(danmu.timestamp);
                   dateCell.title = `发送于: ${formatDate(danmu.timestamp)}`;

                   row.appendChild(timeCell);
                   row.appendChild(contentCell);
                   row.appendChild(dateCell);
                   danmukuTableBody.appendChild(row);
               });
           }
       }

       // --- Event Listeners for Panel ---
       danmukuListButton.addEventListener("click", (e) => {
           e.stopPropagation();
           toggleDanmukuPanel();
       });
       danmukuOverlay.addEventListener("click", (e) => {
           e.stopPropagation();
           toggleDanmukuPanel(false);
       });

       // Return control object
       return {
           button: danmukuListButton,
           panel: danmukuListPanel,
           overlay: danmukuOverlay,
           update: updateDanmukuList,
           toggle: toggleDanmukuPanel
       };
   }

   // --- 检测URL是否为m3u8格式 ---
   function isM3u8Url(url) {
       if (!url) return false;
       return url.toLowerCase().includes('.m3u8') || url.toLowerCase().includes('application/x-mpegurl');
   }

   // --- 创建HLS播放器 ---
   function createHlsPlayer(video, url) {
       if (Hls.isSupported()) {
           const hls = new Hls({
               // HLS配置选项
               maxBufferLength: 30,
               maxMaxBufferLength: 60,
               fragLoadingTimeOut: 20000,
               manifestLoadingTimeOut: 20000,
               levelLoadingTimeOut: 20000
           });
           hls.loadSource(url);
           hls.attachMedia(video);
           hls.on(Hls.Events.MANIFEST_PARSED, function() {
               console.log('HLS清单解析完成，可用质量:', hls.levels.length);
               notification.show(`HLS流加载成功，共${hls.levels.length}个质量选项`, 'success', 3000);
           });
           
           hls.on(Hls.Events.ERROR, function(event, data) {
               if (data.fatal) {
                   switch(data.type) {
                       case Hls.ErrorTypes.NETWORK_ERROR:
                           console.error('HLS网络错误:', data);
                           notification.show('HLS网络错误，尝试恢复...', 'error', 3000);
                           hls.startLoad(); // 尝试恢复
                           break;
                       case Hls.ErrorTypes.MEDIA_ERROR:
                           console.error('HLS媒体错误:', data);
                           notification.show('HLS媒体错误，尝试恢复...', 'error', 3000);
                           hls.recoverMediaError(); // 尝试恢复媒体错误
                           break;
                       default:
                           console.error('HLS致命错误:', data);
                           notification.show('HLS播放器错误，无法恢复', 'error', 5000);
                           hls.destroy(); // 无法恢复，销毁实例
                           break;
                   }
               }
           });
           
           return hls;
       } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
           // 原生支持HLS的浏览器（如Safari）
           video.src = url;
           notification.show('使用浏览器原生HLS支持播放', 'info', 3000);
           return null;
       } else {
           notification.show('您的浏览器不支持HLS播放', 'error', 5000);
           return null;
       }
   }

   // --- DOM 加载完成后的初始化 ---
   document.addEventListener('DOMContentLoaded', function () {
    // 初始化在线用户系统
    onlineUserSystem.init();

    // 获取悬浮弹幕面板元素
    const floatingDanmukuPanel = document.getElementById('floating-danmuku-panel');
    const floatingDanmukuClose = document.getElementById('floating-danmuku-close');
    const floatingDanmukuText = document.getElementById('floating-danmuku-text');
    const floatingDanmukuSend = document.getElementById('floating-danmuku-send');
    const floatingDanmukuSwitch = document.getElementById('floating-danmuku-switch');
    const floatingDanmukuColors = document.getElementById('floating-danmuku-colors');
    const floatingDanmukuModes = document.getElementById('floating-danmuku-modes');
    
    // 移动端弹幕控制面板元素
    const mobileDanmukuControls = document.getElementById('mobile-danmuku-controls');
    const mobileDanmukuText = document.getElementById('mobile-danmuku-text');
    const mobileDanmukuSend = document.getElementById('mobile-danmuku-send');
    const mobileDanmukuSwitch = document.getElementById('mobile-danmuku-switch');
    const mobileDanmukuColors = document.getElementById('mobile-danmuku-colors');
    const mobileDanmukuModes = document.getElementById('mobile-danmuku-modes');
    const mobileDanmukuOverlay = document.getElementById('mobile-danmuku-overlay');

    let isMobileDanmukuOpen = false;
    let selectedColor = '#FFFFFF';
    let selectedMode = 0;

    // 添加弹幕按钮到控制栏的函数
    function addDanmukuControlsToPlayer(art) {
        if (!art || !art.template || !art.template.$controlsLeft) {
            console.error("无法找到播放器控制栏");
            return;
        }

        // 创建发送弹幕按钮
        const danmukuSendButton = document.createElement('div');
        danmukuSendButton.className = 'art-control art-control-danmuku-send';
        danmukuSendButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`;
        danmukuSendButton.title = "发送弹幕";
        
        // 创建弹幕显示/隐藏按钮
        const danmukuVisibilityButton = document.createElement('div');
        danmukuVisibilityButton.className = 'art-control art-control-danmuku-visibility';
        danmukuVisibilityButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
        danmukuVisibilityButton.title = "弹幕显示/隐藏";
        danmukuVisibilityButton.style.display = 'none'; // 暂时隐藏，保留功能

        // 添加到控制栏
        // 只在移动端显示这些按钮
        if (mobileMediaQuery.matches) {
            art.template.$controlsLeft.appendChild(danmukuSendButton);
            art.template.$controlsLeft.appendChild(danmukuVisibilityButton);
        } else {
            // 在桌面端隐藏按钮
            danmukuSendButton.style.display = 'none';
            danmukuVisibilityButton.style.display = 'none';
        }

        // 发送弹幕按钮点击事件 - 显示悬浮弹幕面板
        danmukuSendButton.addEventListener('click', () => {
            toggleFloatingPanel(true);
        });

        // 弹幕显示/隐藏按钮点击事件
        danmukuVisibilityButton.addEventListener('click', () => {
            if (artInstance && artInstance.plugins && artInstance.plugins.artplayerPluginDanmuku) {
                isDanmukuVisible = !isDanmukuVisible;
                if (isDanmukuVisible) {
                    artInstance.plugins.artplayerPluginDanmuku.show();
                    danmukuVisibilityButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
                    notification.show('弹幕已显示', 'success', 2000);
                } else {
                    artInstance.plugins.artplayerPluginDanmuku.hide();
                    danmukuVisibilityButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>`;
                    notification.show('弹幕已隐藏', 'info', 2000);
                }
                
                // 同步开关状态
                mobileDanmukuSwitch.checked = isDanmukuVisible;
                floatingDanmukuSwitch.checked = isDanmukuVisible;
            }
        });

        return {
            sendButton: danmukuSendButton,
            visibilityButton: danmukuVisibilityButton
        };
    }

    // 悬浮弹幕面板控制函数
    function toggleFloatingPanel(show) {
        if (show === undefined) {
            show = !isFloatingPanelOpen;
        }
        
        isFloatingPanelOpen = show;
        
        if (show) {
            floatingDanmukuPanel.classList.add('show');
            // 聚焦输入框
            setTimeout(() => floatingDanmukuText.focus(), 300);
            
            // 添加点击视频区域关闭面板的事件
            if (artInstance && artInstance.template && artInstance.template.$video) {
                artInstance.template.$video.addEventListener('click', closeFloatingPanelOnVideoClick);
            }
        } else {
            floatingDanmukuPanel.classList.remove('show');
            
            // 移除点击视频区域关闭面板的事件
            if (artInstance && artInstance.template && artInstance.template.$video) {
                artInstance.template.$video.removeEventListener('click', closeFloatingPanelOnVideoClick);
            }
        }
    }
    
    // 点击视频区域关闭悬浮面板的函数
    function closeFloatingPanelOnVideoClick(e) {
        // 确保点击的是视频区域而不是控制栏或其他元素
        if (e.target === artInstance.template.$video) {
            toggleFloatingPanel(false);
        }
    }

    // 关闭悬浮弹幕面板按钮事件
    floatingDanmukuClose.addEventListener('click', () => {
        toggleFloatingPanel(false);
    });

    // 点击遮罩层关闭弹幕发送窗口
    mobileDanmukuOverlay.addEventListener('click', () => {
        isMobileDanmukuOpen = false;
        mobileDanmukuControls.classList.remove('show');
        mobileDanmukuOverlay.style.display = 'none';
        document.querySelector('.artplayer-app').classList.remove('mobile-danmuku-open');
    });

    // 悬浮面板颜色选择
    const floatingColorOptions = floatingDanmukuColors.querySelectorAll('.color-option');
    floatingColorOptions.forEach(option => {
        option.addEventListener('click', () => {
            floatingColorOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            selectedColor = option.getAttribute('data-color');
        });
    });

    // 悬浮面板模式选择
    const floatingModeOptions = floatingDanmukuModes.querySelectorAll('.mode-option');
    floatingModeOptions.forEach(option => {
        option.addEventListener('click', () => {
            floatingModeOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            selectedMode = parseInt(option.getAttribute('data-mode'));
        });
    });

    // 悬浮面板弹幕开关
    floatingDanmukuSwitch.addEventListener('change', () => {
        if (artInstance && artInstance.plugins && artInstance.plugins.artplayerPluginDanmuku) {
            isDanmukuVisible = floatingDanmukuSwitch.checked;
            if (isDanmukuVisible) {
                artInstance.plugins.artplayerPluginDanmuku.show();
                notification.show('弹幕已开启', 'success', 2000);
            } else {
                artInstance.plugins.artplayerPluginDanmuku.hide();
                notification.show('弹幕已关闭', 'info', 2000);
            }
            
            // 同步其他开关状态
            mobileDanmukuSwitch.checked = isDanmukuVisible;
        }
    });

    // 移动端颜色选择
    const colorOptions = mobileDanmukuColors.querySelectorAll('.color-option');
    colorOptions.forEach(option => {
        option.addEventListener('click', () => {
            colorOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            selectedColor = option.getAttribute('data-color');
        });
    });

    // 移动端模式选择
    const modeOptions = mobileDanmukuModes.querySelectorAll('.mode-option');
    modeOptions.forEach(option => {
        option.addEventListener('click', () => {
            modeOptions.forEach(opt => opt.classList.remove('active'));
            option.classList.add('active');
            selectedMode = parseInt(option.getAttribute('data-mode'));
        });
    });

    // 移动端弹幕开关
    mobileDanmukuSwitch.addEventListener('change', () => {
        if (artInstance && artInstance.plugins && artInstance.plugins.artplayerPluginDanmuku) {
            isDanmukuVisible = mobileDanmukuSwitch.checked;
            if (isDanmukuVisible) {
                artInstance.plugins.artplayerPluginDanmuku.show();
                notification.show('弹幕已开启', 'success', 2000);
            } else {
                artInstance.plugins.artplayerPluginDanmuku.hide();
                notification.show('弹幕已关闭', 'info', 2000);
            }
            
            // 同步悬浮面板开关状态
            floatingDanmukuSwitch.checked = isDanmukuVisible;
        }
    });

    // 发送弹幕函数
    function sendDanmuku(text) {
        if (!text) {
            notification.show('弹幕内容不能为空', 'error', 2000);
            return;
        }
        
        if (artInstance && artInstance.plugins && artInstance.plugins.artplayerPluginDanmuku) {
            // 先获取当前播放时间
            const currentTime = artInstance.currentTime;
            
            // 准备发送到后端的数据
            const postData = {
                text: text,
                time: currentTime,
                color: selectedColor,
                mode: selectedMode,
                timestamp: Date.now(),
                obvId: obvId
            };
            
            // 发送到后端
            fetch('/sendDanmaku', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(postData)
            })
            .then(res => {
                if (!res.ok) { throw new Error(`弹幕服务器响应错误: ${res.status}`); }
                return res.json();
            })
            .then(responseData => {
                console.log("弹幕发送响应:", responseData);
                notification.show('弹幕发送成功', 'success', 2000);
                
                // 本地显示弹幕
                artInstance.plugins.artplayerPluginDanmuku.emit({
                    text: text,
                    color: selectedColor,
                    mode: selectedMode
                });
                
                // 添加到全局数据
                const newDanmuData = {
                    text: text,
                    time: currentTime,
                    color: selectedColor,
                    mode: selectedMode,
                    timestamp: postData.timestamp
                };
                
                globalDanmukuData.push(newDanmuData);
                globalDanmukuData.sort((a, b) => (a.timestamp || a.time) - (b.timestamp || b.time));
                
                // 更新列表
                if (isDanmukuPanelOpen && danmukuListControl) {
                    danmukuListControl.update();
                }
                
                // 清空输入框
                mobileDanmukuText.value = '';
                floatingDanmukuText.value = '';
                
                // 关闭弹幕发送面板
                isMobileDanmukuOpen = false;
                mobileDanmukuControls.classList.remove('show');
                mobileDanmukuOverlay.style.display = 'none';
                document.querySelector('.artplayer-app').classList.remove('mobile-danmuku-open');
                
                // 关闭悬浮面板
                toggleFloatingPanel(false);
            })
            .catch(err => {
                notification.show('弹幕发送失败', 'error', 3000);
                console.error('弹幕发送失败:', err);
            });
        } else {
            notification.show('弹幕系统未初始化', 'error', 2000);
        }
    }

    // 移动端发送弹幕
    mobileDanmukuSend.addEventListener('click', () => {
        sendDanmuku(mobileDanmukuText.value.trim());
    });
    
    mobileDanmukuText.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendDanmuku(mobileDanmukuText.value.trim());
        }
    });
    
    // 悬浮面板发送弹幕
    floatingDanmukuSend.addEventListener('click', () => {
        sendDanmuku(floatingDanmukuText.value.trim());
    });
    
    floatingDanmukuText.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendDanmuku(floatingDanmukuText.value.trim());
        }
    });

    // Notification based on dmk parameter state
    if (!hasDmkParam) {
        notification.show('该视频没有弹幕数据', 'info', 3000);
    }

    try {
        const initialFontSize = getDanmakuFontSize(mobileMediaQuery.matches);
        console.log(`设备检测: ${mobileMediaQuery.matches ? '移动端' : '桌面端'}, 初始弹幕字号: ${initialFontSize}`);

        // --- 创建 Artplayer 配置对象 ---
        const artplayerOptions = {
            container: '.artplayer-app',
            url: videoUrl,
            autoSize: false,
            fullscreen: true,
            playbackRate: true,
            miniProgressBar: true,
            autoPlayback: true,
            fastForward: true,
            clickToPlay: true,
            contextmenu: [
                {
                    html: '发送反馈',
                    click: () => {
                        try { window.parent.MAC.Gbook.Report(``); }
                        catch (e) { notification.show('请使用播放器右侧菜单[<]进行反馈！', 'info', 3000); console.error('视频反馈提示', e); }
                    },
                },
                {
                    html: 'OBP v2.1.2', // Updated version
                    click: () => {
                        try { window.parent.MAC.Gbook.Report(``); }
                        catch (e) { notification.show('OBP 2.1.2 | ThinkPHP Edition', 'success', 3000); console.error('OBP INFO', e); }
                    },
                },
            ],
            plugins: [
                artplayerPluginDanmuku({
                    danmuku: () => {
                        // 使用预加载的弹幕数据
                        console.log("使用数据库弹幕数据:", preloadedDanmakuData.length);
                        globalDanmukuData = preloadedDanmakuData;
                        return Promise.resolve(preloadedDanmakuData);
                    },
                    speed: 5,
                    margin: [10, 10],
                    opacity: 1,
                    color: '#FFFFFF',
                    mode: 0,
                    heatmap: hasDmkParam, // Show heatmap if we have danmaku
                    points: [],
                    modes: [0, 1, 2],
                    fontSize: initialFontSize,
                    antiOverlap: false,
                    emitter: hasDmkParam, // Enable emitter if we have danmaku
                    maxLength: 20,
                    lockTime: 5,
                    theme: 'dark',
                    beforeEmit: (danmu) => {
                        if (!hasDmkParam) {
                            notification.show('无法发送弹幕：该视频没有弹幕数据', 'error', 3000);
                            return false; // Artplayer expects boolean or Promise<boolean>
                        }

                        return new Promise(resolve => {
                            const content = danmu.text.trim();
                            if (!content) {
                                notification.show('弹幕不能为空！', 'error', 2000);
                                return resolve(false);
                            }

                            const currentTime = artInstance ? artInstance.currentTime : 0;
                            const postData = {
                                text: content,
                                time: currentTime,
                                color: danmu.color,
                                mode: danmu.mode,
                                timestamp: Date.now(), // Add current timestamp
                                obvId: obvId // Add video ID for database storage
                            };

                            fetch('/sendDanmaku', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json'
                                },
                                body: JSON.stringify(postData)
                            })
                            .then(res => {
                                if (!res.ok) { throw new Error(`弹幕服务器响应错误: ${res.status}`); }
                                // Assuming success if status is 2xx
                                return res.json();
                            })
                            .then(responseData => {
                                console.log("弹幕发送响应:", responseData);
                                notification.show('弹幕发送成功', 'success', 2000);

                                // Create the danmu object matching globalDanmukuData structure
                                const newDanmuData = {
                                    text: content,
                                    time: currentTime,
                                    color: danmu.color,
                                    mode: danmu.mode, // Keep original mode
                                    timestamp: postData.timestamp // Use the timestamp sent
                                };

                                // Add to global data immediately for list update
                                globalDanmukuData.push(newDanmuData);
                                // Re-sort global data if timestamp is crucial for order
                                globalDanmukuData.sort((a, b) => (a.timestamp || a.time) - (b.timestamp || b.time));

                                // Update list if open
                                if (isDanmukuPanelOpen && danmukuListControl) {
                                    danmukuListControl.update();
                                }

                                resolve(true); // Allow Artplayer to also display the danmu
                            })
                            .catch(err => {
                                notification.show('弹幕发送失败', 'error', 3000);
                                console.error('弹幕发送失败:', err);
                                resolve(false); // Prevent Artplayer from displaying
                            });
                        });
                    }
                }),
            ],
            // 添加自定义播放器事件处理
            customType: {
                m3u8: function(video, url) {
                    // 使用HLS.js处理m3u8视频
                    createHlsPlayer(video, url);
                }
            }
        };

        // --- 条件化添加字幕配置 ---
        if (subtitleUrl) {
            console.log(`检测到字幕文件，尝试加载: ${subtitleUrl}`);
            let subtitleType = 'srt';
            const urlExtension = subtitleUrl.split('.').pop().toLowerCase();
            if (urlExtension === 'vtt') subtitleType = 'vtt';

            artplayerOptions.subtitle = {
                url: subtitleUrl,
                type: subtitleType,
                encoding: 'utf-8',
                style: {
                    color: '#FFFFFF',
                    fontSize: '20px',
                    'text-shadow': '1px 1px 1px rgba(0, 0, 0, 0.8), -1px -1px 1px rgba(0, 0, 0, 0.8), 1px -1px 1px rgba(0, 0, 0, 0.8), -1px 1px 1px rgba(0, 0, 0, 0.8)'
                },
            };
            notification.show('尝试加载字幕..', 'info', 3000);
        } else {
            console.log("未检测到字幕文件参数");
        }

        // --- 初始化 Artplayer ---
        console.log("Artplayer 初始化选项:", artplayerOptions);
        artInstance = new Artplayer(artplayerOptions); // Assign to global instance

        // --- 添加弹幕列表功能 ---
        // Store the control object returned by the function
        const danmukuListControl = addDanmukuListFeature(artInstance);
        
        // --- 添加弹幕控制按钮到播放器控制栏 ---
        const danmukuControls = addDanmukuControlsToPlayer(artInstance);

        // --- 检测视频URL是否为m3u8格式 ---
        if (isM3u8Url(videoUrl)) {
            notification.show('检测到M3U8格式视频，使用HLS播放器', 'info', 3000);
        }

        // --- Artplayer 事件监听 ---
        artInstance.on('ready', () => {
            notification.hide(loadingId);
            notification.show('播放器准备就绪', 'success', 2000);
            updateDanmakuFontSize(); // Initial font size check
            
            // 初始化移动端弹幕开关状态
            if (artInstance.plugins.artplayerPluginDanmuku) {
                mobileDanmukuSwitch.checked = true;
                floatingDanmukuSwitch.checked = true;
                isDanmukuVisible = true;
            }
            // Initial update for danmuku list header info after player is ready
            if (danmukuListControl) danmukuListControl.update();
        });

        artInstance.on('error', (error, reconnectTime) => {
            notification.hide(loadingId);
            let errorMsg = `播放器错误: ${error.message || '可能是网络错误'}`;
            if (reconnectTime !== undefined && reconnectTime >= 0) {
                errorMsg += `，第${reconnectTime}次重连...`;
                notification.show(errorMsg, 'error', reconnectTime * 1000 + 1000);
            } else {
                errorMsg += `，请检查网络连接`;
                notification.show(errorMsg, 'error', 5000);
            }
            console.error('Artplayer 错误:', error, '重连时间:', reconnectTime);
        });

        // Subtitle events
        artInstance.on('subtitleLoad', (url) => {
            console.log('字幕加载成功:', url);
            notification.show('字幕加载成功', 'success', 2000);
        });
        artInstance.on('subtitleError', (error) => {
            console.error('字幕加载失败:', error);
            notification.show(`字幕加载失败: ${error.message || '无法加载字幕文件'}`, 'error', 4000);
        });

        // Danmuku plugin events
        artInstance.on('artplayerPluginDanmuku:loaded', (danmus) => {
            // This event fires *after* the loadDanmukuData completes via the 'danmuku' option function
            const count = Array.isArray(danmus) ? danmus.length : 0;
            if (hasDmkParam) {
                notification.show(`已装填加载 ${count} 条弹幕`, 'info', 3000);
            }
            // Update the list panel now that data is confirmed loaded into plugin
            if (danmukuListControl) danmukuListControl.update();
            globalDanmukuData = Array.isArray(danmus) ? danmus : []; // Sync global data with plugin's data
        });

        artInstance.on('artplayerPluginDanmuku:error', (error) => {
            console.error("弹幕插件错误:", error);
            notification.show(`弹幕加载或处理失败: ${error.message || '未知弹幕错误'}`, 'error', 5000);
            // Update list to show error or empty state
            if (danmukuListControl) danmukuListControl.update();
        });

    } catch (error) {
        notification.hide(loadingId);
        notification.show('播放器初始化过程中发生严重错误', 'error', 0);
        console.error('播放器初始化失败 (Catch Block):', error);
    }
});

   // --- Cleanup on Page Unload ---
   window.addEventListener('unload', () => {
       // Remove resize listener
       if (mobileMediaQuery.removeEventListener) {
           mobileMediaQuery.removeEventListener('change', debouncedUpdateFontSize);
       } else if (mobileMediaQuery.removeListener) {
           mobileMediaQuery.removeListener(debouncedUpdateFontSize);
       }
       // Optional: Clear heartbeat interval if not handled by beforeunload
       if (onlineUserSystem && onlineUserSystem.heartbeatInterval) {
           clearInterval(onlineUserSystem.heartbeatInterval);
       }
       // Optional: Destroy Artplayer instance if needed
       if (artInstance && typeof artInstance.destroy === 'function') {
           try { artInstance.destroy(false); } // Pass false to keep the container element
           catch(e) { console.warn("销毁 Artplayer 实例时出错:", e); }
       }
   });
</script>
</body>
</html>
